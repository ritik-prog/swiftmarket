const Product = require('../models/Product');
const natural = require('natural');

// Search products
exports.searchProducts = async (req, res, next) => {
    try {
        const query = req.query.q;
        if (!query) {
            return res.status(400).json({ message: 'Query parameter is missing' });
        }

        // Tokenize the query using the natural library
        const tokenizer = new natural.WordTokenizer();
        const tokens = tokenizer.tokenize(query.toLowerCase());

        // Build the query object
        const queryObject = {
            $and: [
                { isAvailable: true },
                {
                    $or: [
                        { productName: { $regex: query, $options: 'i' } },
                        { businessUsername: { $regex: query, $options: 'i' } },
                        { tags: { $in: tokens } },
                        { $text: { $search: query } },
                        {
                            $expr: {
                                $gt: [{ $size: { $setIntersection: ['$keywords', tokens] } }, 0]
                            }
                        }
                    ]
                }
            ]
        };

        // Execute the search query
        const products = await Product.find(queryObject)
            .select('-reviews -updatedAt -updatedBy -isAvailable -__v')
            .populate({
                path: 'seller',
                select: 'businessName businessEmail businessNumber'
            })
            .sort({ createdAt: -1 });

        return res.status(200).json(products);
    } catch (error) {
        console.error(error);
        return res.status(500).json({ message: 'Internal server error' });
    }
};

// models/Product.js
const { Schema, model } = require('mongoose');
const natural = require('natural');

const productSchema = new Schema(
    {
        // ...
        productName: { type: String, required: true },
        businessName: { type: String, required: true },
        productDescription: { type: String, required: true },
        category: { type: String, required: true },
        // ...
        keywords: { type: [String], default: [] },
        // ...
    },
    { timestamps: true }
);

productSchema.pre('save', function (next) {
    const tokenizer = new natural.WordTokenizer();
    const stemmer = natural.PorterStemmer;
    const stopwords = natural.stopwords;

    const keywords = [
        ...tokenizer.tokenize(this.productName),
        ...tokenizer.tokenize(this.businessName),
        ...tokenizer.tokenize(this.productDescription),
        ...tokenizer.tokenize(this.category),
        ...tokenizer.tokenize(this.tags),
    ]
        .map((word) => stemmer.stem(word.toLowerCase()))
        .filter((word) => !stopwords.includes(word))
        .filter(Boolean);

    this.keywords = keywords;

    next();
});

// Search for products based on keywords
async function searchProducts(req, res) {
    const { q } = req.query;

    if (!q) {
        return res.status(400).json({ message: 'Search query is required' });
    }

    try {
        const products = await Product.find({
            $text: { $search: q },
            keywords: { $in: q.toLowerCase().split(' ') }
        }).populate('seller');
        res.json({ products });
    } catch (error) {
        console.error(error);
        res.status(500).json({ message: 'Internal server error' });
    }
}